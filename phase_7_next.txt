7: Advanced Next.js Features - Interceptors, Middleware, and More
1. Interceptors in Next.js

Interceptors are typically used in API calls or HTTP requests to modify or handle requests and responses globally, such as adding authentication tokens, logging requests, or handling errors. While Next.js doesn’t have built-in interceptors like in some frameworks, we can create a custom solution using libraries like Axios or Fetch API to implement similar functionality.

Why Use Interceptors?

Add Authorization: Attach tokens (JWT, API keys) to headers.

Handle Errors Globally: Catch errors from all requests in one place.

Modify Requests/Responses: Change request data before sending or modify the response before use.

Example with Axios Interceptors:

Install Axios:

npm install axios


Set Up Axios Interceptor:

import axios from 'axios';

// Create an Axios instance
const axiosInstance = axios.create({
  baseURL: 'https://api.example.com/',
});

// Request Interceptor - Add Authorization Token
axiosInstance.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('authToken');
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response Interceptor - Handle Errors Globally
axiosInstance.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response && error.response.status === 401) {
      // Handle Unauthorized Error (Redirect to login)
      console.log('Unauthorized, redirecting to login...');
    }
    return Promise.reject(error);
  }
);

export default axiosInstance;


Request Interceptor: Adds an authorization token to every outgoing request.

Response Interceptor: Handles errors globally, for example, by redirecting the user to a login page if an authorization error occurs.

Using Axios in Next.js Pages:
import axiosInstance from '../utils/axiosInstance';

const fetchData = async () => {
  try {
    const response = await axiosInstance.get('/data');
    console.log(response.data);
  } catch (error) {
    console.error(error);
  }
};

2. Middleware in Next.js

Middleware in Next.js is used for running code between the request and the response. It allows you to implement functionality such as authentication, logging, and redirects.

Why Use Middleware?

Authentication and Authorization: Protect routes that require authentication.

Redirect Logic: Perform custom redirects based on certain conditions.

Handling Errors: Catch and manage errors before sending the response to the client.

Creating Middleware in Next.js (Edge or Traditional Middleware)

Basic Middleware Example:
In Next.js, you can add middleware to your app by creating a middleware.js file at the root of your project.

Example - Protecting Routes (Auth Middleware):
// middleware.js
import { NextResponse } from 'next/server';

export function middleware(req) {
  const token = req.cookies.get('auth-token');
  
  if (!token) {
    // Redirect user to login if not authenticated
    return NextResponse.redirect('/login');
  }

  return NextResponse.next();
}


This middleware checks if the user has a valid authentication token in the cookies. If not, it redirects to the login page.

Redirect Middleware:
You can also handle redirects based on custom conditions, such as URL parameters, user role, or language preferences.

Example - Redirecting based on Language:
// middleware.js
import { NextResponse } from 'next/server';

export function middleware(req) {
  const { pathname } = req.nextUrl;
  const preferredLanguage = req.cookies.get('preferred-lang') || 'en';

  // Redirect to the preferred language page
  if (pathname === '/') {
    return NextResponse.redirect(`/${preferredLanguage}`);
  }

  return NextResponse.next();
}


This middleware checks the preferred language of the user (stored in cookies) and redirects them to the appropriate language-specific page.

3. Edge Middleware:

Edge middleware runs on the edge network and can be used to make quick, low-latency decisions (such as redirects or token validation) before the request even reaches the server. It’s particularly useful for things like geolocation-based redirects, A/B testing, and personalization.

3. API Routes and Serverless Functions

Next.js provides an easy way to create API routes inside the pages/api directory. These routes act as serverless functions where you can handle backend logic without needing a separate server.

Why Use API Routes?

Handle form submissions.

Perform database queries.

Manage authentication and authorization.

Implement custom backend logic like sending emails, processing payments, etc.

Creating API Routes:
Basic API Route Example:
// pages/api/hello.js
export default function handler(req, res) {
  res.status(200).json({ message: 'Hello from Next.js API!' });
}


This API route responds to a GET request at /api/hello with a JSON message.

Example - Handling POST Request (Form Submission):
// pages/api/contact.js
export default function handler(req, res) {
  if (req.method === 'POST') {
    const { name, message } = req.body;
    // Handle the POST data (e.g., save to database)
    res.status(200).json({ status: 'Success', name, message });
  } else {
    res.status(405).json({ status: 'Method Not Allowed' });
  }
}


This example demonstrates handling a POST request, extracting data from the body, and sending a response.

4. Authentication with JWT in Next.js

JSON Web Tokens (JWT) are widely used for authentication in web applications. Next.js can handle JWT-based authentication for user authentication and authorization.

Steps to Implement JWT Authentication:

Generate a JWT Token:

Use a login API to authenticate users and return a JWT token.

Login API Example:
// pages/api/login.js
import jwt from 'jsonwebtoken';

export default function handler(req, res) {
  if (req.method === 'POST') {
    const { username, password } = req.body;

    // Verify user credentials (simplified for example purposes)
    if (username === 'admin' && password === 'password') {
      const token = jwt.sign({ username }, 'secret-key', { expiresIn: '1h' });
      res.status(200).json({ token });
    } else {
      res.status(401).json({ message: 'Unauthorized' });
    }
  } else {
    res.status(405).json({ message: 'Method Not Allowed' });
  }
}


This API returns a JWT token upon successful login.

Storing the Token:

Store the token in localStorage or cookies for client-side access.

Protecting Routes:

You can protect specific pages or API routes by checking for a valid JWT token in the request headers or cookies.

Example - Protecting Pages with Middleware:
// middleware.js
import { NextResponse } from 'next/server';
import jwt from 'jsonwebtoken';

export function middleware(req) {
  const token = req.cookies.get('auth-token');
  
  if (!token) {
    return NextResponse.redirect('/login');
  }

  try {
    jwt.verify(token, 'secret-key');
  } catch (error) {
    return NextResponse.redirect('/login');
  }

  return NextResponse.next();
}


This middleware verifies the JWT token before allowing access to a protected page.

5. Internationalization (i18n) in Next.js

Next.js supports internationalization (i18n) out-of-the-box, allowing you to build multi-language websites. You can define multiple locales and handle routing for different languages.

Setting Up i18n in Next.js:

Configure next.config.js:

// next.config.js
module.exports = {
  i18n: {
    locales: ['en', 'fr', 'de'],
    defaultLocale: 'en',
  },
};


locales: Array of languages your site supports.

defaultLocale: The default language for your app.

Accessing Language in Pages:

// pages/index.js
export default function HomePage() {
  return <h1>Welcome to My Multi-Language Site</h1>;
}


Next.js automatically handles routes for /en, /fr, and /de based on the locale.

6. Deployment of Next.js Application

Vercel is the recommended deployment platform for Next.js. It provides serverless functions, automatic scaling, and optimized performance for Next.js apps.

Deploying on Vercel:

Sign up at Vercel
.

Link your GitHub repository to Vercel.

Push your code, and Vercel will automatically deploy your app.

Other Platforms:

You can also deploy Next.js on Netlify, AWS, Heroku, or any platform that supports Node.js.