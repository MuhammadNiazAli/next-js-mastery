2: Next.js Advanced Features and Best Practices
1. Dynamic Routing in Next.js

Next.js supports dynamic routing through the use of dynamic file names with brackets. This feature is useful for creating pages that change based on parameters, such as user profiles, blog posts, or products.

Dynamic Routing Syntax:

In Next.js, you create dynamic routes by wrapping the file name in square brackets.

Example:
// pages/[id].js
export default function DynamicPage({ id }) {
  return <h1>Page for ID: {id}</h1>;
}


Accessing Dynamic Routes:
If you visit /123, the id will be 123, and the component will render accordingly.

Nested Dynamic Routes:

You can also have nested dynamic routes for more complex routing structures.

Example:
// pages/products/[category]/[id].js
export default function ProductPage({ category, id }) {
  return <h1>Product {id} in Category: {category}</h1>;
}


This will handle routes like /products/electronics/123.

2. API Routes in Next.js

API Routes in Next.js allow you to build API endpoints directly inside your Next.js application without needing a separate backend server. These API routes can be created inside the pages/api folder, and each file in this folder automatically becomes an API endpoint.

Creating an API Route:

Create a file inside the pages/api directory:

pages/api/hello.js


Write the API handler:
In the handler, you can access the req (request) and res (response) objects to send a response.

// pages/api/hello.js
export default function handler(req, res) {
  res.status(200).json({ message: 'Hello World' });
}


This file automatically becomes accessible at /api/hello.

API Route Example with Query Parameters:

You can handle query parameters and dynamic API routes in a similar manner to dynamic pages.

// pages/api/products/[id].js
export default function handler(req, res) {
  const { id } = req.query;
  res.status(200).json({ productId: id });
}


This route would handle API requests like /api/products/123, and the response would be { productId: '123' }.

Handling Methods in API Routes:

You can handle different HTTP methods like GET, POST, PUT, etc., inside a single API route file.

// pages/api/user.js
export default function handler(req, res) {
  if (req.method === 'GET') {
    res.status(200).json({ message: 'Fetching user data' });
  } else if (req.method === 'POST') {
    res.status(201).json({ message: 'Creating user' });
  } else {
    res.status(405).json({ message: 'Method Not Allowed' });
  }
}

3. Data Fetching Methods in Next.js (Detailed)

Next.js provides multiple methods for fetching data, depending on your application's needs: getStaticProps, getServerSideProps, and getInitialProps (deprecated).

a. getStaticProps (Static Site Generation - SSG)

Purpose: getStaticProps is used for static site generation (SSG). It fetches data at build time and generates static HTML.

When to use: Use this when the data doesn't change frequently, and you want fast loading and SEO-friendly pages.

Example:
// pages/index.js
export async function getStaticProps() {
  const res = await fetch('https://api.example.com/posts');
  const posts = await res.json();

  return {
    props: {
      posts,
    },
  };
}

export default function Home({ posts }) {
  return (
    <div>
      <h1>Blog Posts</h1>
      {posts.map((post) => (
        <div key={post.id}>{post.title}</div>
      ))}
    </div>
  );
}


Static Generation: The data is fetched during build time, and static HTML pages are created.

b. getServerSideProps (Server-Side Rendering - SSR)

Purpose: getServerSideProps is used for server-side rendering (SSR). It fetches data on each request and generates HTML dynamically on the server.

When to use: Use this when you need the data to be fetched on each request (e.g., dynamic data that updates frequently).

Example:
// pages/index.js
export async function getServerSideProps() {
  const res = await fetch('https://api.example.com/posts');
  const posts = await res.json();

  return {
    props: {
      posts,
    },
  };
}

export default function Home({ posts }) {
  return (
    <div>
      <h1>Blog Posts</h1>
      {posts.map((post) => (
        <div key={post.id}>{post.title}</div>
      ))}
    </div>
  );
}


Server-Side Rendering: The data is fetched on each request, and the server sends pre-rendered HTML to the client.

c. getInitialProps (Deprecated)

Purpose: getInitialProps is an older method used for data fetching. However, it is now deprecated in favor of getStaticProps and getServerSideProps for better performance and flexibility.

4. Image Optimization in Next.js

Next.js has built-in support for optimizing images, which helps improve the performance of your app.

Using the Image Component:

Import the Image Component:

Next.js provides an <Image> component from next/image that automatically optimizes the images.

Image Component Example:

import Image from 'next/image';

export default function HomePage() {
  return (
    <div>
      <h1>Optimized Image Example</h1>
      <Image
        src="/images/landscape.jpg"
        alt="Landscape"
        width={500}
        height={300}
      />
    </div>
  );
}


Benefits:

Automatic resizing: Next.js resizes images based on the device size and resolution.

Lazy loading: Images are lazy-loaded by default, meaning they are only loaded when they come into the viewport.

5. Environment Variables in Next.js

Next.js supports environment variables, which you can use to securely store sensitive information like API keys, database credentials, etc.

Setting up Environment Variables:

Create a .env.local file in the root directory of your project.

Define environment variables in the .env.local file:

NEXT_PUBLIC_API_URL=https://api.example.com
SECRET_KEY=my-secret-key


NEXT_PUBLIC_ prefix: Any environment variable that starts with NEXT_PUBLIC_ is exposed to the client-side JavaScript, and can be accessed from the browser.

Accessing Environment Variables:
// pages/index.js
export async function getServerSideProps() {
  const apiUrl = process.env.NEXT_PUBLIC_API_URL;
  const res = await fetch(`${apiUrl}/posts`);
  const posts = await res.json();

  return {
    props: { posts },
  };
}

6. API Routes for Backend in Next.js

API Routes in Next.js let you create backend functionality within your Next.js project, making it easier to handle server-side logic, authentication, and data processing.

Creating API Routes:

Define an API Route in pages/api folder.

// pages/api/contact.js
export default function handler(req, res) {
  if (req.method === 'POST') {
    const { name, message } = req.body;
    // Process the form data (e.g., save to database)
    res.status(200).json({ status: 'success', name, message });
  } else {
    res.status(405).json({ status: 'Method Not Allowed' });
  }
}


Calling the API Route:
You can use fetch or any HTTP client like Axios to call API routes from your frontend or other parts of the application.

7. Deploying Next.js Application

Next.js can be easily deployed on platforms like Vercel and Netlify, which offer optimized serverless deployment.

Deploying on Vercel:

Sign up at Vercel
.

Connect your GitHub repository with Vercel.

Deploy your Next.js app by clicking on the "Deploy" button in Vercelâ€™s dashboard.

Vercel automatically optimizes the Next.js application and provides serverless functions for API routes, making deployment easier.